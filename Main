
Abstract Data Types:

Primitive Data Types:
=====================
int, double, boolean, char. 

Class Data Types:
====================
Fruit, Car, Television, Album 
(They represent real-world things that are tangible in nature)

Abstract Data Types:
====================
'Abstract'means something that isn't tangible or concrete - it only exists as an idea. 
For instance, religion, justice, etc. 
Abstract Data Types are defined by how they work, rather than how they are defined. 

Formal definition: An Abstract Data Type is an entity that is defined by how it functions
and not by how it is implemented or constructed. 


Interfaces 
====================
- Interfaces are a set of requirements for a class to implement. These requirements are listed or represented as method headings). The Interface will include a set of method headers that a class must provide an implementation for.
- An interface will not have constructors or instance variables 
- The headers will consist of an access modifier, a return type, the name of the method, and any parameters.  
- A class that chooses to 'implement' an interface must implement all method headings listed in the interface. 
- The idea of an interface is analogous to a contract in law, where two or more parties agree to be part of an agreement that must be followed. 
- In the same way, a class is a blueprint for an object, and an interface is a blueprint for a class. 
- There are now 3 levels: An interface, a class, and an object. 
- Class that chooses to implement an interface will use the keyword 'implements', E.g, 'ArrayBasedStack implements StackInterface' 
 
Exception Handling
==========================================================================================================
- An exception is an occurance of an unusual event. 
- The exceptions are represented as special objects that inherit from the in-built 'Exception' class. 
- Exceptions do not have instance variables or methods - they merely have 1-2 constructors 
- The first constructor is a non-parameter constructor that makes a call to super()
- The second constructor is a paramter-based constructor that recieves a 'String message' variable 
  and the call to super() accepts message by super(message) 
- We may 'throw' and 'catch' exceptions - where 'throwing' an exception creates an object of the Exception
  class, and 'catching' the exception is handling the exceptional case.
- Exceptions don't have instance variables because we know what is happening when the throwing an exception
  and there is no need to store additional information. 
- Creating an exception will create a new Exception object that is polymorphic. 
- For instance, a StackFullException will be of type Object, Throwable, Exception, and
  itself - StackFullException. 
  
 ==>> Example of Exception:<<==

public class StackFullException extends Exception { //must extend 'Exception' 
	
	//no instance variables 
	public StackFullException() {
		super(); //call to the Exception class constructor - as such, the class does not have instance variables  
	}
	
	//overloaded constructor 
	public StackFullException(String message) {
		super(message); //call to overloaded Exception class that accepts 'message'...  
	}
	
	//has no non-static methods 
}

==>> Example of Method that throws an Exception <<==

//Methods that 'may' throw an exception will have 'throws ExceptionName' 
//Within the body, 'throw new ExceptionName(MessageOfChoice) 

public void pop() throws StackEmptyException { 
		if(top == -1) {
			throw new StackEmptyException("Stack is Empty"); 
		} 
		else {
			stack[top] = null; 
			top--; 
		}
}

==========================================================================================================


  
Heirarchy of Exceptions 
=========================
Since an Exception is a child of Throwable, and since our Exceptions inherit from Exception, we can throw our Exceptions. 
[Object] -> [Throwable] -> [Exception] -> Any Exception you might create (StackEmptyException/StackFullException)




Stack ADT
====================================================================================================================================
 ==>> ArrayBasedStack.java <<== 

- Items are added to the top of the stack, and items are removed from the top of the stack 
  such that the last item added to the stack will be the first item removed from the stack 
- The Stack ADT is LIFO: Last In First Out 
- Stack ADTs usually have the following: Push, Pop, and Peek.

public class ArrayBasedStack<T> extends Object implements StackInterface<T> {
	//instance variables 
	private int top; 
	private  T[] stack; //we could have said 'Object stack' here but that would allow for different data-types to enter the stack. So, instead.. we choose 'T'  
	
	public ArrayBasedStack() {
		super(); 
		top = -1; 
		stack = (T[])new Object[100]; //again, if we just just did Object[100] - we could have multiple object types within our stack - so we type-cast it to the T we want. 
	}
	
	public ArrayBasedStack(int sizeOfStack) {
		super(); //still making call to super() <- must come first 
		top = -1; //top is still given default value 
		//checking for valid sizeOfStack 
		if(sizeOfStack > 0) {
			stack = (T[])new Object[sizeOfStack];
		}
		else {
			stack = (T[])new Object[100];
		}
	}
	
	public void push(T item) throws StackFullException {
		/*
		 *pushing implies we should check if the stack is full (it being empty / not full are both positive cases)
		 *we know that the total number of indices contained within an array of size X should be X-1. (0 through X-1) (Eg. Array length 10 should have 0-9 indices).
		 *So, if the length is 10 and the highest index is 9, we are in bounds for an array of length 10. But, if the index reference touches 10, then it's OOB. 
		 *The array should thus be considered 'full' if the top index (which keeps track of where to populate) is equal to the last index in an array of length X, which would be X-1. 
		*/
		if(top == stack.length-1) { 
			throw new StackFullException("Stack is full"); 
		} 
		else {
			//move top up by one so that it can be positioned at a vacant space 
			//then within that vacant space, store 'item' that was passed in by user 
			top++; 
			stack[top] = item; 
		}	
	}
	
	public void pop() throws StackEmptyException {
		//Cannot pop from an empty stack - so, we will say if top == -1, then throw exception; else, go through removing process. 
		//CSC223 has it such that if top >= 0 then it's safe to remove; otherwise throw exception. 
		if(top == -1) {
			throw new StackEmptyException("Stack is Empty"); 
		} 
		else {
			stack[top] = null; 
			top--; 
		}
	}
	
	public T peek() throws StackEmptyException {
		//recall, this is condition for 'empty'... so if it's empty, through exception, else return stack[top]... with that said
		//CSC223 has this as if(top >= 0) then return stack[top], else throw exception. 
		if(top == -1) {
			throw new StackEmptyException(); 
		}
		return stack[top]; 		
	}
	
	
	//this is just for demonstration but we can have isEmpty isFull methods -> this method can replace condition in push
	public boolean isFull() {
		return(top == stack.length-1); 
	}
	
	//this is just for demonstration, but we can have isEmpty method -> this method can replace condition in pop
	public boolean isEmpty() {
		return(top == -1); 
	}
	
	public void print() { 
		int elements = top+1; 
		for(int i = 0; i < elements; i++) {
			System.out.println(stack[i]); 
		}
	}
	
	/*
	 * Alternate version of pop()
	 * 
	 * public void pop() throws StackEmptyException {
	 *    if(top >= 0) {
	 * 	    stack[top] = null; 
	 * 	    top--;
	 *    else {
	 * 	     throw new StackEmptyException("Pop attempted on an empty stack!"); 
	 * 	  }
	 *   }
	 * }
	 */
	
	/*
	 * Alternate version of push()
	 * 
	 * public void push(T item) throws StackFullException {
	 * 
	 * 		if(top < stack.length - 1) {
	 * 			top++; 
	 * 			stack[top] = item; 
	 * 		}
	 * 		else {
	 * 			throw new StackFullException("Push attempted on a full stack"); 
	 * 		}
	 * }
	 */
	
	
	/*
	 * Alternate version of peek() 
	 * 
	 * public T peek(T item) throws StackEmptyException {
	 * 		 
	 * 		T value = null; 
	 * 			
	 * 		if(top >= 0) {
	 * 			
	 * 			value = stack[top]; 
	 * 			
	 * 		}
	 * 		else {
	 * 			throw new StackEmptyException();
	 * 		}
	 * 		return value; 
	 * }
	 */
}


==>> StackInterface.java <<==
package Stack;

public interface StackInterface<T> {

	//if the stack is full, this method will throw 'StackFullException'; otherwise, it places the item it receives on-top of the stack. 
	public void push(T item) throws StackFullException;  
	
	//if the stack is empty, this method will throw 'StackEmptyException'; otherwise it will remove an item from the top of the stack 
	public void pop() throws StackEmptyException; 
	
	//if the stack is empty, this method will throw 'StackEmptyException'; otherwise, it will return the item on the top of the stack. 
	public T peek() throws StackEmptyException; 
	
}

==>> StackFullException.java <<==

/*
 * Classes that are built around 'Exceptions' extend (inherit) from the 'Exception class'
 * Typically, Exception classes do not have any instance variables. 
 * They typically have two constructors - one that accommodates a message, and one that doesn't. 
 * Both constructors will make a call the the parent's constructor which is 'Exception'. 
 */


  =>> StackFullException.java <<=
  
public class StackFullException extends Exception { //must extend 'Exception' 
	
	//no instance variables 
	public StackFullException() {
		super(); //call to the Exception class constructor - as such, the class does not have instance variables  
	}
	
	//overloaded constructor 
	public StackFullException(String message) {
		super(message); //call to overloaded Exception class that accepts 'message'...  
	}
	
	//has no non-static methods 

}


  =>> StackEmptyException.java <<=

/*
 * Classes that are built around 'Exceptions' extend (inherit) from the 'Exception class'
 * Typically, Exception classes do not have any instance variables. 
 * They typically have two constructors - one that accommodates a message, and one that doesn't. 
 * Both constructors will make a call the the parent's constructor which is 'Exception'. 
 */


public class StackEmptyException extends Exception {
	
	public StackEmptyException() {
		super(); 
	}
	
	public StackEmptyException(String message) {
		super(message); 
	}
	
}

==>> StackDemo.java Version 1 <<== 
//When we run into StackFullException, we will not execute any code afterwards and executation will halt.
//If we want the code to run, we must surround code that might breed specific exceptions in their own 
//try catch. 
public class StackDemo {

	public static void main(String[] args) {
		ArrayBasedStack<String> stack = new ArrayBasedStack<>(3);

		try {
			stack.push("Dexter");
			stack.push("Better Call Saul");
			stack.push("Game of Thrones");
			stack.push("House of Cards"); // this will not get added to the stack but the program will still continue
		
			System.out.println("Top of stack: " + stack.peek());
			System.out.println("Now popping..");
			stack.pop();

			System.out.println("Top of stack: " + stack.peek());
			System.out.println("Now popping..");
			stack.pop();

			System.out.println("Top of stack: " + stack.peek());
			System.out.println("Now popping..");
			stack.pop();

		}
		catch(StackFullException e1) {
			System.out.println(e1.getMessage()); 
		}
		catch(StackEmptyException e2) {
			System.out.println(e2.getMessage());
		}

	}
}
====================================================================================================================================


Lecture 14:

Static Allocation of Memory:
============================
- Limitation of using an array-based stack implementation is that the implementation uses 
 'Static Memory Allocation', in that once the size of the array is declared (by either the program or
  the user) then it cannot be increased in the event the stack is full. We throw an exception; however, 
  we cannot accomodate more items. 
 - We should not choose to store 1000 or 10mil for our size because then we are consuming memory 
   that might not be used. 
 - Static Allocation of Memory involes or happens when the amount of memory that is reserved for use does not
   change as the program executes. The amount of memory that is reserved is either determined when the
   program is written when the memory is allocated, but does not change from that point forward. 

Dynamic Allocation of Memory:
============================
- Dynamic Allocation of Memory involves or happens when the amount of memory that is reserved for changes
  as the program executes. 
- The amount of memory that is allocation can increase or decrease as needed by the program. 
- Dynamic Allocation of Memory is facilated by an Object called a 'Node' which has comprises of 
  a piece of data and a reference to the next Node. So, as such, you can always increase the size by 
  adding and chaining Nodes. 
  
 >>> The Node Class <<<
==========================================================================================================
 
 public class Node<T> {

    //instance variables
    private T data;
    private Node<T> link; //reference to an object of the Node<T> class

    //constructor that receives data
    //the data passed in will refer to the global data field
    //Every node created floats in memory at first, and link is not referring to anything.
    public Node(T data) {
        this.data = data;
        link = null;
    }

    //non-static methods
    public void setData(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

    public void setLink(Node<T> otherNode) {
        this.link = otherNode;
    }

    public Node<T> getLink() {
        return link;
    }

}

==>> NodeDemo 1 <<== 

public class NodeDemo {

    public static void main(String[] args) {

        //firstNode & secondNode are references to a Node object
        // firstNode -> [data: Dune | link: secondNode]
        //secondNode -> [data: X | link: null]

        Node<String> firstNode = new Node<String>("Dune");
        Node<String> secondNode = new Node<String>("1984");

        firstNode.setLink(secondNode);

        //prints 1984
        System.out.println(firstNode.getLink().getData());
    }
}

==> NodeDemo 2 <==
public class NodeDemo {

    public static void main(String[] args) {

        //firstNode & secondNode are references to a Node object
        // firstNode -> [data: Dune | link: secondNode]
        //secondNode -> [data: X | link: null]

        Node<String> firstNode = new Node<String>("Dune");
        Node<String> secondNode = new Node<String>("1984");
        Node<String> thirdNode = new Node<>("Animal Farm");
        firstNode.setLink(secondNode);
        secondNode.setLink(thirdNode);

        //Activity: Loop through all items and print content. 

        Node<String> current = firstNode;

        while(current != null) {
            System.out.println(current.getData());
            current = current.getLink();

        }
    }
}
==========================================================================================================





