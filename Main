
Abstract Data Types:

Primitive Data Types:
========================================================================================================================================================
These are built-in data types wihthin the language - class data types are data-types we create. 
int, double, boolean, char. 
========================================================================================================================================================

Class Data Types:
========================================================================================================================================================
Fruit, Car, Television, Album 
(They represent real-world things that are tangible in nature)

Abstract Data Types:
========================================================================================================================================================
'Abstract'means something that isn't tangible or concrete - it only exists as an idea. 
For instance, religion, justice, etc. 
Abstract Data Types are defined by how they work, rather than how they are defined. 

Formal definition: An Abstract Data Type is an entity that is defined by how it functions
and not by how it is implemented or constructed. 
========================================================================================================================================================


Interfaces 
========================================================================================================================================================
- Interfaces are a set of requirements for a class to implement. These requirements are listed or represented as method headings). The Interface will include a set of method headers that a class must provide an implementation for.
- An interface will not have constructors or instance variables 
- The headers will consist of an access modifier, a return type, the name of the method, and any parameters.  
- A class that chooses to 'implement' an interface must implement all method headings listed in the interface. 
- The idea of an interface is analogous to a contract in law, where two or more parties agree to be part of an agreement that must be followed. 
- In the same way, a class is a blueprint for an object, and an interface is a blueprint for a class. 
- There are now 3 levels: An interface, a class, and an object. 
- Class that chooses to implement an interface will use the keyword 'implements', E.g, 'ArrayBasedStack implements StackInterface' 

========================================================================================================================================================
 
Exception Handling
========================================================================================================================================================
- An exception is an occurance of an unusual event. 
- The exceptions are represented as special objects that inherit from the in-built 'Exception' class. 
- Exceptions do not have instance variables or methods - they merely have 1-2 constructors 
- The first constructor is a non-parameter constructor that makes a call to super()
- The second constructor is a paramter-based constructor that recieves a 'String message' variable 
  and the call to super() accepts message by super(message) 
- We may 'throw' and 'catch' exceptions - where 'throwing' an exception creates an object of the Exception
  class, and 'catching' the exception is handling the exceptional case.
- Exceptions don't have instance variables because we know what is happening when the throwing an exception
  and there is no need to store additional information. 
- Creating an exception will create a new Exception object that is polymorphic. 
- For instance, a StackFullException will be of type Object, Throwable, Exception, and
  itself - StackFullException. 
  
 ==>> Example of Exception:<<==

public class StackFullException extends Exception { //must extend 'Exception' 
	
	//no instance variables 
	public StackFullException() {
		super(); //call to the Exception class constructor - as such, the class does not have instance variables  
	}
	
	//overloaded constructor 
	public StackFullException(String message) {
		super(message); //call to overloaded Exception class that accepts 'message'...  
	}
	
	//has no non-static methods 
}

==>> Example of Method that throws an Exception <<==

//Methods that 'may' throw an exception will have 'throws ExceptionName' 
//Within the body, 'throw new ExceptionName(MessageOfChoice) 

public void pop() throws StackEmptyException { 
		if(top == -1) {
			throw new StackEmptyException("Stack is Empty"); 
		} 
		else {
			stack[top] = null; 
			top--; 
		}
}

========================================================================================================================================================


  
Heirarchy of Exceptions 
========================================================================================================================================================
Since an Exception is a child of Throwable, and since our Exceptions inherit from Exception, we can throw our Exceptions. 
[Object] -> [Throwable] -> [Exception] -> Any Exception you might create (StackEmptyException/StackFullException)
========================================================================================================================================================




Stack ADT

========================================================================================================================================================
 ==>> ArrayBasedStack.java <<== 

- Items are added to the top of the stack, and items are removed from the top of the stack 
  such that the last item added to the stack will be the first item removed from the stack 
- The Stack ADT is LIFO: Last In First Out 
- Stack ADTs usually have the following: Push, Pop, and Peek.

public class ArrayBasedStack<T> extends Object implements StackInterface<T> {
	//instance variables 
	private int top; 
	private  T[] stack; //we could have said 'Object stack' here but that would allow for different data-types to enter the stack. So, instead.. we choose 'T'  
	
	public ArrayBasedStack() {
		super(); 
		top = -1; 
		stack = (T[])new Object[100]; //again, if we just just did Object[100] - we could have multiple object types within our stack - so we type-cast it to the T we want. 
	}
	
	public ArrayBasedStack(int sizeOfStack) {
		super(); //still making call to super() <- must come first 
		top = -1; //top is still given default value 
		//checking for valid sizeOfStack 
		if(sizeOfStack > 0) {
			stack = (T[])new Object[sizeOfStack];
		}
		else {
			stack = (T[])new Object[100];
		}
	}
	
	public void push(T item) throws StackFullException {
		/*
		 *pushing implies we should check if the stack is full (it being empty / not full are both positive cases)
		 *we know that the total number of indices contained within an array of size X should be X-1. (0 through X-1) (Eg. Array length 10 should have 0-9 indices).
		 *So, if the length is 10 and the highest index is 9, we are in bounds for an array of length 10. But, if the index reference touches 10, then it's OOB. 
		 *The array should thus be considered 'full' if the top index (which keeps track of where to populate) is equal to the last index in an array of length X, which would be X-1. 
		*/
		if(top == stack.length-1) { 
			throw new StackFullException("Stack is full"); 
		} 
		else {
			//move top up by one so that it can be positioned at a vacant space 
			//then within that vacant space, store 'item' that was passed in by user 
			top++; 
			stack[top] = item; 
		}	
	}
	
	public void pop() throws StackEmptyException {
		//Cannot pop from an empty stack - so, we will say if top == -1, then throw exception; else, go through removing process. 
		//CSC223 has it such that if top >= 0 then it's safe to remove; otherwise throw exception. 
		if(top == -1) {
			throw new StackEmptyException("Stack is Empty"); 
		} 
		else {
			stack[top] = null; 
			top--; 
		}
	}
	
	public T peek() throws StackEmptyException {
		//recall, this is condition for 'empty'... so if it's empty, through exception, else return stack[top]... with that said
		//CSC223 has this as if(top >= 0) then return stack[top], else throw exception. 
		if(top == -1) {
			throw new StackEmptyException(); 
		}
		return stack[top]; 		
	}
	
	
	//this is just for demonstration but we can have isEmpty isFull methods -> this method can replace condition in push
	public boolean isFull() {
		return(top == stack.length-1); 
	}
	
	//this is just for demonstration, but we can have isEmpty method -> this method can replace condition in pop
	public boolean isEmpty() {
		return(top == -1); 
	}
	
	public void print() { 
		int elements = top+1; 
		for(int i = 0; i < elements; i++) {
			System.out.println(stack[i]); 
		}
	}
	
	/*
	 * Alternate version of pop()
	 * 
	 * public void pop() throws StackEmptyException {
	 *    if(top >= 0) {
	 * 	    stack[top] = null; 
	 * 	    top--;
	 *    else {
	 * 	     throw new StackEmptyException("Pop attempted on an empty stack!"); 
	 * 	  }
	 *   }
	 * }
	 */
	
	/*
	 * Alternate version of push()
	 * 
	 * public void push(T item) throws StackFullException {
	 * 
	 * 		if(top < stack.length - 1) {
	 * 			top++; 
	 * 			stack[top] = item; 
	 * 		}
	 * 		else {
	 * 			throw new StackFullException("Push attempted on a full stack"); 
	 * 		}
	 * }
	 */
	
	
	/*
	 * Alternate version of peek() 
	 * 
	 * public T peek(T item) throws StackEmptyException {
	 * 		 
	 * 		T value = null; 
	 * 			
	 * 		if(top >= 0) {
	 * 			
	 * 			value = stack[top]; 
	 * 			
	 * 		}
	 * 		else {
	 * 			throw new StackEmptyException();
	 * 		}
	 * 		return value; 
	 * }
	 */
}


==>> StackInterface.java <<==
package Stack;

public interface StackInterface<T> {

	//if the stack is full, this method will throw 'StackFullException'; otherwise, it places the item it receives on-top of the stack. 
	public void push(T item) throws StackFullException;  
	
	//if the stack is empty, this method will throw 'StackEmptyException'; otherwise it will remove an item from the top of the stack 
	public void pop() throws StackEmptyException; 
	
	//if the stack is empty, this method will throw 'StackEmptyException'; otherwise, it will return the item on the top of the stack. 
	public T peek() throws StackEmptyException; 
	
}

==>> StackFullException.java <<==

/*
 * Classes that are built around 'Exceptions' extend (inherit) from the 'Exception class'
 * Typically, Exception classes do not have any instance variables. 
 * They typically have two constructors - one that accommodates a message, and one that doesn't. 
 * Both constructors will make a call the the parent's constructor which is 'Exception'. 
 */


  =>> StackFullException.java <<=
  
public class StackFullException extends Exception { //must extend 'Exception' 
	
	//no instance variables 
	public StackFullException() {
		super(); //call to the Exception class constructor - as such, the class does not have instance variables  
	}
	
	//overloaded constructor 
	public StackFullException(String message) {
		super(message); //call to overloaded Exception class that accepts 'message'...  
	}
	
	//has no non-static methods 

}


  =>> StackEmptyException.java <<=

/*
 * Classes that are built around 'Exceptions' extend (inherit) from the 'Exception class'
 * Typically, Exception classes do not have any instance variables. 
 * They typically have two constructors - one that accommodates a message, and one that doesn't. 
 * Both constructors will make a call the the parent's constructor which is 'Exception'. 
 */


public class StackEmptyException extends Exception {
	
	public StackEmptyException() {
		super(); 
	}
	
	public StackEmptyException(String message) {
		super(message); 
	}
	
}

==>> StackDemo.java Version 1 <<== 
//When we run into StackFullException, we will not execute any code afterwards and executation will halt.
//If we want the code to run, we must surround code that might breed specific exceptions in their own 
//try catch. 
public class StackDemo {

	public static void main(String[] args) {
		ArrayBasedStack<String> stack = new ArrayBasedStack<>(3);

		try {
			stack.push("Dexter");
			stack.push("Better Call Saul");
			stack.push("Game of Thrones");
			stack.push("House of Cards"); // this will not get added to the stack but the program will still continue
		
			System.out.println("Top of stack: " + stack.peek());
			System.out.println("Now popping..");
			stack.pop();

			System.out.println("Top of stack: " + stack.peek());
			System.out.println("Now popping..");
			stack.pop();

			System.out.println("Top of stack: " + stack.peek());
			System.out.println("Now popping..");
			stack.pop();

		}
		catch(StackFullException e1) {
			System.out.println(e1.getMessage()); 
		}
		catch(StackEmptyException e2) {
			System.out.println(e2.getMessage());
		}

	}
}
========================================================================================================================================================


Lecture 14:

Static Allocation of Memory:
========================================================================================================================================================
- Limitation of using an array-based stack implementation is that the implementation uses 
 'Static Memory Allocation', in that once the size of the array is declared (by either the program or
  the user) then it cannot be increased in the event the stack is full. We throw an exception; however, 
  we cannot accomodate more items. 
 - We should not choose to store 1000 or 10mil for our size because then we are consuming memory 
   that might not be used. 
 - Static Allocation of Memory involes or happens when the amount of memory that is reserved for use does not
   change as the program executes. The amount of memory that is reserved is either determined when the
   program is written when the memory is allocated, but does not change from that point forward. 
 - Dynamic Memory Allocation: [the process of assigning the memory space during the execution time or the run time] 
 - Static Memory Allocation: [memory is allocated for declared variables by the compiler]

Dynamic Allocation of Memory:
========================================================================================================================================================
- Dynamic Allocation of Memory involves or happens when the amount of memory that is reserved for changes
  as the program executes. 
- The amount of memory that is allocation can increase or decrease as needed by the program. 
- Dynamic Allocation of Memory is facilated by an Object called a 'Node' which has comprises of 
  a piece of data and a reference to the next Node. So, as such, you can always increase the size by 
  adding and chaining Nodes. 
  
 >>> The Node Class <<<
========================================================================================================================================================
 
 public class Node<T> {

    //instance variables
    private T data;
    private Node<T> link; //reference to an object of the Node<T> class

    //constructor that receives data
    //the data passed in will refer to the global data field
    //Every node created floats in memory at first, and link is not referring to anything.
    public Node(T data) {
        this.data = data;
        link = null;
    }

    //non-static methods
    public void setData(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

    public void setLink(Node<T> otherNode) {
        this.link = otherNode;
    }

    public Node<T> getLink() {
        return link;
    }

}

==>> NodeDemo 1 <<== 

public class NodeDemo {

    public static void main(String[] args) {

        //firstNode & secondNode are references to a Node object
        // firstNode -> [data: Dune | link: secondNode]
        //secondNode -> [data: X | link: null]

        Node<String> firstNode = new Node<String>("Dune");
        Node<String> secondNode = new Node<String>("1984");

        firstNode.setLink(secondNode);

        //prints 1984
        System.out.println(firstNode.getLink().getData());
    }
}

==> NodeDemo 2 <==
public class NodeDemo {

    public static void main(String[] args) {

        //firstNode & secondNode are references to a Node object
        // firstNode -> [data: Dune | link: secondNode]
        //secondNode -> [data: X | link: null]

        Node<String> firstNode = new Node<String>("Dune");
        Node<String> secondNode = new Node<String>("1984");
        Node<String> thirdNode = new Node<>("Animal Farm");
        firstNode.setLink(secondNode);
        secondNode.setLink(thirdNode);

        //Activity: Loop through all items and print content. 

        Node<String> current = firstNode;

        while(current != null) {
            System.out.println(current.getData());
            current = current.getLink();

        }
    }
}

========================================================================================================================================================
Stack Implemented with Nodes:
/*
 * The Stack with Links - adding a new item goes above item 1 and top moves up
 * 
 * 	    [top] ===>   	[ item 1 ]
 * 				   ||	
 * 				   ||		
 * 				   \/
 * 				[ item2 ]
 * 
 * 				   ||	
 * 				   ||		
 * 				   \/
 * 				[ item 3]
 * 				   ||
 * 				   ||
 * 				   \/
 * 				
 */	

>> NodeBasedStack.java << 
public class NodeBasedStack<T> implements UnboundedStackInterface<T> {

	private Node<T> top;

	public NodeBasedStack() {
		top = null;
	}

	@Override
	public void pop(T item) throws StackEmptyException {

		if (top == null) {
			throw new StackEmptyException("Stack is empty");
		} else {
			top = top.getLink();
		}
	}

	@Override
	public String peek() {
		if (top == null) {
			return "Stack is Empty";
		} else {
			return top.getData().toString();
		}
	}

	@Override
	public void push(T item) {
		Node<T> currentNode = new Node<T>(item);

		if (top == null) {
			top = currentNode;
		} 
		else {
			currentNode.setLink(top);
			top = currentNode;
		}
	}

	public void print() {
		Node<T> current = top;

		while (current != null) {
			System.out.println(current.getData());

			current = current.getLink();
		}
	}

}

>> StackInterface.java << 

public interface StackInterface<T> {
	
	public void push(T item) throws StackFullException; 
	
	public void pop(T item) throws StackEmptyException;
	
	public String peek(); 

}

>> UnboundedStackInterface <<

public interface UnboundedStackInterface<T> extends StackInterface<T> {
	
	
	/*
	 * Since UnboundedStackInterface extends StackInterface; all of the 
	 * method headers defined StackInterface are available and known to know
	 * UnboundedStackInterface. We don't need to rewrite the method headers
	 * that we want within UnboundedStack that are within StackInterface, 
	 * but we may Override a header we want to change. 
	 * For instance, StackInterface has a 'push' method that throws 
	 * a StackFullException. Our unbounded stack can never be full so we
	 * want to have a 'push' header in our UnboundedStackInterface that
	 * does not throw this exception. 
	 */
	
	public void push(T item); 

}

>> Node.java <<

public class Node<T> {
	
	//instance variables
    private T data;
    private Node<T> link; //reference to an object of the Node<T> class

    //constructor that receives data
    //the data passed in will refer to the global data field
    //Every node created floats in memory at first, and link is not referring to anything.
    public Node(T data) {
        this.data = data;
        link = null;
    }

    //non-static methods
    public void setData(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

    public void setLink(Node<T> otherNode) {
        this.link = otherNode;
    }

    public Node<T> getLink() {
        return link;
    }

}

>> StackEmptyException << 
public class StackEmptyException extends Exception {

	public StackEmptyException() {
		super(); 
	}
	
	public StackEmptyException(String message) {
		super(message); 
	}
	
}

>> StackFullException <<
public class StackFullException extends Exception {

		public StackFullException() {
			super(); 
		}
		
		public StackFullException(String message) {
			super(message); 
		}
}

>> UnboundedStack.java <<
public class UnboundedStackDemo {
	
	public static void main(String[] args) {
		
		NodeBasedStack<String> stack = new NodeBasedStack<String>();
		stack.push("Jacob");
		stack.push("Tony");
		stack.push("Matthew");
		
		System.out.println(stack.peek());
		
		
	}
}
========================================================================================================================================================

Queue Abstract Data Type:
- A queue is when items are added to the rear of the queue, but items are removed from the
front of the queue. The queue operates on a FIFO basis - First In First Out. 
The way a Queue works is analogous to a way a line works - those first are the first out, and those
last are the last out. 

- When the first item is added to the queue, it is both the 'front' and the 'rear' 

- [item 1] [item 2] [item 3] 
    \ front 	 	\ rear 
    
- Enqueue adds to the back of the queue 
- Dequeue removes from the front of the queue 

=>> QueueInterface.java <<==

public interface QueueInterface<T> {
	
	public void enqueue(T value) throws QueueFullException; 
	
	//removes and returns item at the front of the quee
	//otherwise throws QueueEmptyException
	public T dequeue() throws QueueEmptyException; 

	
	//string representation of front of queue 
	public String look(); 	
}

=>> QueueFullException <<== 
public class QueueFullException extends Exception {

	public QueueFullException() {
		super(); 
	}
	
	public QueueFullException(String message) {
		super(message); 
	}
	
}

==>> QueueEmptyException.java <<== 

public class QueueEmptyException extends Exception {
	
	public QueueEmptyException() {
		super(); 
	}
	
	public QueueEmptyException(String message) {
		super(message); 
	}

}

==>> ArrayBasedQueue.java <<==
package QueueProgram;

/*
 * if rear == queue.length-1 will mean that the rear has reached the last element
 * which is referenced by the last index in the array. 
 * 
 * If that is the case, we want rear to equal 0, otherwise just move forward. 
 */


public class ArrayBasedQueue<T> implements QueueInterface<T> {

	private T[] queue;
	private int front;
	private int rear; 
	private int numberOfItems; 
	
	public ArrayBasedQueue() {
		this.queue =  (T[]) new Object[10];
		front = 0; 
		rear = 0; 
		numberOfItems = 0; 
	}
	
	public ArrayBasedQueue(int size) {
		if(size < 0) {
			this.queue =  (T[]) new Object[10];
		}
		else {
			this.queue =  (T[]) new Object[size];
		}
	}
	
	
	@Override
	public void enqueue(T item) throws QueueFullException {
		/*
		 * Since the length = items in an array
		 * if items = length, then queue is full. 
		 * 
		 * would be if(numberOfItems < queue.length) then 
		 * queue[rear] = item; 
		 * rear++; 
		 * numberOfItems++ 
		 * but we want to wrap rear around 
		 */
		
		if(numberOfItems < queue.length) {
			queue[rear] = item;
			numberOfItems++; 
			/*
			 * We added an item to rear since it's valid 
			 * But, if rear is now on the last element, wrap it around to front. 
			 * Otherwise status quo, add one to rear. 
			 */
			if(rear == queue.length-1) {
				rear = 0; 
			}
			else {
				rear++;
			}
			
		}
		else {
			throw new QueueFullException("Cannot enqueue on full queue");
		}
	}
	
	int counter = 0; 
	public void print() {
		
		System.out.println(counter + " iteration "); 
		System.out.println("======================");
		for(int i = 0; i < queue.length; i++) {
			System.out.println(queue[i]);   
		}
		System.out.println("======================");
		counter++; 
	}
	
	public void printLast() {
		System.out.println(queue[rear].toString());
	}

	@Override
	public T dequeue() throws QueueEmptyException {
		T value = null; 
		//judge if queue is empty
		if(numberOfItems == 0) {
			throw new QueueEmptyException("Queue is empty"); 
		}
		else {
			value = queue[front];  
			queue[front] = null; 
			front++;
			numberOfItems--; 
		}
		return value; 
	}

	@Override
	public String look() {
		String frontItem = ""; 
		if(numberOfItems > 0) {
			frontItem = queue[front].toString(); 
		}
		else {
			System.out.println("Cannot look on empty queue"); 
		}
		return frontItem; 
	}

}

==>> QueueDemo.java <<==
package QueueProgram;

import java.util.Scanner;

public class QueueDemo {

	public static void main(String[] args) {

		Scanner keyboard = new Scanner(System.in); 
		
		QueueInterface<String> queue = new ArrayBasedQueue<String>(5);

		int option;
		do {
			
			System.out.println("Press 1 to add a song to the playlist"); 
			System.out.println("Press 2 to remove a song from the playlist"); 
			System.out.println("Press 3 to look at song in front"); 
			System.out.println("Press 4 to end the program");
			option = keyboard.nextInt(); 
			keyboard.nextLine(); 
			
			if (option == 1) {
				System.out.println("Enter name of song: "); 
				String song = keyboard.nextLine(); 
				
				try {
					queue.enqueue(song);
				} 
				catch (QueueFullException e) {
					System.out.println(e.getMessage()); 
				}
			}
			else if (option == 2) {
				try {
					System.out.println(queue.dequeue());
				} 
				catch (QueueEmptyException e) {
					System.out.println(e.getMessage()); 
				} 
			}
			else if (option == 3) {
				System.out.println(queue.look()); 
			}
			else if (option == 4) {
				System.out.println("Thank you."); 
			}
			else {
				System.out.println("Invalid option entered"); 
			}


		} while (option != 4);

	}

}

=======================================================================================================================================================

Node.java

public class Node<T> extends Object {
	
	private T data;
	private Node<T> link; 
	
	public Node(T data) {
		super(); 
		this.data = data; 
		this.link = null; 
	}
	
	public void setLink(Node<T> otherNode) {
		this.link = otherNode;
	}
	
	public T getData() {
		return this.data; 
	}
	
	public Node<T> getLink() {
		return link; 
	}

}


public class QueueEmptyException extends Exception {
	
	public QueueEmptyException() {
		super(); 
	}
	
	public QueueEmptyException(String message) {
		super(message); 
	}
	
}

public class QueueFullException extends Exception {
	
	public QueueFullException() {
		super(); 
	}
	
	public QueueFullException(String message) {
		super(message); 
	}

}

public interface QueueInterface<T> {
	
	public void enqueue(T item) throws QueueFullException; 
	
	public T dequeue() throws QueueEmptyException; 
	
	public String look(); 

}


public interface UnboundedQueueInterface<T> extends QueueInterface<T>{

	/*
	 * These were in the QueueInterface 
	 * 
	 * 	public void enqueue(T item); 
	 *
	 *	public T dequeue() throws QueueEmptyException; 
	 *
	 *	public String look(); 
	 * 
	 * dequeue and look are available in the same way they are noted in QueueInterface, but since we have added an implementation for enqueue - 
	 * it overrides the default implementation. Namely, in this case, enqueue 
	 * 
	 */
	
	
	public void enqueue(T item); 

}

package NodeBasedQueue;

public class NodeBasedQueue<T> extends Object implements UnboundedQueueInterface<T>{

	private Node<T> front; 
	private Node<T> rear; 
	//private int numberOfItems; 
	
	
	public NodeBasedQueue() {
		super(); 
		front = null; 
		rear = null; 
		//this.numberOfItems = 0; 
	}
	
	@Override
	public T dequeue() throws QueueEmptyException {
		if(isEmpty()) {
			throw new QueueEmptyException("Dequeue attempted on empty queue"); 
		}
		else {
			T frontItem = front.getData(); 
			front = front.getLink(); 
			//special case when we remove all items - front points to null but rear does? So update rear as well. 
			if(front == null) {
				rear = null; 
			}
			//numberOfItems--; 
			return frontItem; 
		}
	}
	
	public boolean isEmpty() {
		return(front == null && rear == null); 
	}

	@Override
	public String look() {
		String frontItem = ""; 
		if(isEmpty()) {
			frontItem = "Queue is Empty"; 
		}
		else {
			frontItem = front.getData().toString(); 
		}
		return frontItem; 
	}

	@Override
	public void enqueue(T item) {
		
		Node<T> currentNode = new Node<T>(item); 
		
		//can never be full
		if(front == null && rear == null) {
			front = currentNode; 
			rear = currentNode; 
			//numberOfItems++; 
		}
		else {
			rear.setLink(currentNode);
			rear = currentNode; 
			//numberOfItems++; 
		}
		
	}
}

public class NodeBasedQueueDemo {
	
	public static void main(String[] args) {
		NodeBasedQueue<String> waitList = new NodeBasedQueue<String>(); 
		
		System.out.println(waitList.look()); 
		
		waitList.enqueue("Jack");
		waitList.enqueue("Jill");
		waitList.enqueue("Joe");
		
		System.out.println(waitList.look()); 
		
		
		try {
			System.out.println("Removed from front: " + waitList.dequeue());
			System.out.println(waitList.look()); 
			System.out.println("Removed from front: " + waitList.dequeue());
			System.out.println(waitList.look()); 
			System.out.println("Removed from front: " + waitList.dequeue());
			System.out.println(waitList.look()); 
		} 
		catch (QueueEmptyException e) {
			System.out.println(e.getMessage()); 
		} 
		
		System.out.println(waitList.look()); 

	}

}

=========================================================================================================================================================

List:

package ListProject;

public interface ListInterface<T> {
	
	//adds item to list 
	public void add(T item); 
	
	//if item exists, remove and return true; else do opposite. 
	public boolean remove(T item); 
	
	public boolean find(T item);

	
}

package ListProject;

public class ArrayBasedList<T> implements ListInterface<T> {

	private int numberOfItems;
	private T[] list;

	public ArrayBasedList() {
		list = (T[]) new Object[5];
		numberOfItems = 0;
	}

	public ArrayBasedList(int size) {
		numberOfItems = 0;
		if (size > 0) {
			list = (T[]) new Object[size];
		} else {
			list = (T[]) new Object[5];
		}
	}

	@Override
	public void add(T item) {

		if (numberOfItems < list.length) { // numberOfItems < list.length means list isn't full, equal case would go to
											// else.
			list[numberOfItems] = item;
			numberOfItems++;
		} else {
			// This is the if we are full case. We create a list that is double the length,
			// and then have new list be old list.
			T[] largerList = (T[]) new Object[list.length * 2];
			for (int i = 0; i < list.length; i++) {
				largerList[i] = list[i];
			}
			// copy item intended into new list - remember, 'numberOfItems' serves as our
			// index as well.
			largerList[numberOfItems] = item;
			numberOfItems++;
			list = largerList; // update reference
		}
	}

//	public boolean find(T item) {
//		/*
//		 * Using while loop - allows us to stop as soon as we hit a case where item is
//		 * found. Only do index < numberOfItems and not index < list.length since we
//		 * only want to check area that is filled.
//		 */
//		boolean found = false;
//		int index = 0;
//
//		while (!found && index < numberOfItems) {
//			if (list[index].equals(item)) {
//				found = true;
//			} else {
//				index++;
//			}
//		}
//		return found;
//	}
	
	
	public boolean find(T item) {
		boolean found = false; 
		int index = locate(item); 
		if(index != -1) {
			found = true; 
		}
		return found; 
	}
	
	public String toString() {
		String toReturn = ""; 
		for(int i = 0; i < numberOfItems; i++) {
			toReturn  = toReturn + list[i].toString() + "\n";
		}
		return toReturn; 
	}

//	public boolean remove(T item) {
//		boolean found = find(item);
//		boolean removed = false;
//
//		if (found == true) {
//
//			int index = 0;
//
//			while (removed == false && index < numberOfItems) {
//				if (list[index].equals(item)) {
//					list[index] = null;
//					removed = true;
//					numberOfItems--;
//
//					// now we're going to do something different here - list is [x][x][x][x] but
//					// when we remove, like with [x][x][][x][x] well
//					// since we don't care about order we can take last item and drop it into the
//					// newly created vacant space
//					list[index] = list[numberOfItems];
//					list[numberOfItems] = null;
//				} else {
//					index++;
//				}
//			}
//		}
//
//		return removed;
//	}
	
	
	public boolean remove(T item) {
		int index = locate(item); 
		boolean removed = false; 
		if(index != -1) {
			list[index] = null;
			numberOfItems--;
			list[index] = list[numberOfItems];
			list[numberOfItems] = null;
			removed = true;
		}
		return removed; 
		
	}
	

	// helper method - private. Is not a part of the interface, so private helper
	// methods can be in class even if it isn't defined in interface
	//this is an implemenative detail 
	private int locate(T item) {
		int index = 0;
		boolean found = false;

		while (!found && index < numberOfItems) {
			if (list[index].equals(item)) {
				found = true;
			} else {
				index++;
			}
		}

		if(found == false) {
			index = -1; 
		}
		
		//otherwise index would be holding valid location since index never got a chance to update after initial find 
		return index; 

	}

}


package ListProject;

import java.util.Scanner;

public class ListDemo2 {
	
	public static void main(String[] args) {
		Scanner keyboard = new Scanner(System.in);
		
		ListInterface<String> myList = new ArrayBasedList<String>(2); 
		
		int option; 
		do {
			System.out.println("Press 1 to add an item to the list"); 
			System.out.println("Press 2 to remove an item from the list");
			System.out.println("Press 3 to find an item from the list");
			System.out.println("Press 4 to end the program"); 
			option = keyboard.nextInt();
			keyboard.nextLine(); 
			
			if(option == 1) {
				System.out.println("Enter item"); 
				String input = keyboard.nextLine();
				myList.add(input); 
			}
			else if(option == 2) {
				System.out.println("Enter item you would like to remove"); 
				String input = keyboard.nextLine();
				myList.remove(input); 
			}
			else if(option == 3) {
				System.out.println("Enter item to remove");
				String input = keyboard.nextLine();
				if(!myList.find(input)) {
					System.out.println("Item not found"); 
				}
				else {
					System.out.println("Item was found!"); 
				}
			}
			else if(option == 4) {
				System.out.println("Thank you for using the program!"); 
			}
			else {
				System.out.println("Please enter a valid option"); 
			}
			System.out.println("LIST NOW: "); 
			System.out.println(myList.toString()); 
		}while(option != 4);
		
	}

}
=====================================================================================================================================================

NodeBasedList:

package NodeBasedList;

public interface ListInterface<T> {
	
	public void add(T item); 
	
	public boolean remove(T item); 
	
	public boolean find(T item); 
	
	public String toString(); 

}

package NodeBasedList;

public class NodeBasedList<T> extends Object implements ListInterface<T> {
	
	private Node list; //reference to node object 
	
	public NodeBasedList() {
		super(); 
		this.list = null; 
	}

	@Override
	public void add(T item) {
		Node<T> currentNode = new Node<>(item); 
		if(list == null) {
			list = currentNode; 
		}
		else {
			//there is no order! no need to traverse and put element to head. Just do a prepend operation. 
			currentNode.setLink(list);
			list = currentNode; 
		}
		
	}
	
	private Node<T> locate(T item) {
		Node<T> toReturn = null; 
		boolean found = false; 
		Node<T> current = list; 
		while(current != null) {
			if(current.getData().equals(item)) {
				toReturn = current; 
				break; 
			}
			current = current.getLink(); 
		}
		return toReturn; 
	}
	
	public boolean find(T item) {
		boolean found = false; 
		//since locate(T item) gives a Node, you cannot store it in a boolean value 
		Node<T> current = locate(item); 
		if(current != null) {
			//we know it was found 
			found = true; 
			
		}
		return found; 
	}
	
	
	
	public String toString() {
		String toReturn = ""; 
		Node<T> current = list; 
		while(current != null) {
			toReturn = toReturn + current.getData().toString() + "\n"; 
			current = current.getLink(); 
		}
		return toReturn; 
		
	}

	@Override
	public boolean remove(T item) {
		boolean verdict = false; 
		while(list != null && list.getData().equals(item)) {
			list = list.getLink(); 
		}
		
		Node<T> prev = null; 
		Node<T> current = list; 
		
		while(current != null) {
			if(current.getData().equals(item)) {
				prev.setLink(prev.getLink().getLink());
			}
			else {
				prev = current; 
			}
			current = current.getLink(); 
		}
	
		return verdict; 
	}
	
	/*
	 * Can create personal 'Node' class within NodeBasedList - this is called an 'inner class' 
	 * which is completely contained inside NodeBasedList. 
	 * For inner-classes, while you don't have access to T data and Node<T> link because they are private
	 * you still have access to public methods (like setData and getData and setLink)
	 */
	
	private class Node<T> {
		//instance variables (same as before, T data, and Node link 
		private T data; 
		private Node<T> link; 
		
		public Node(T data) {
			this.data = data; 
			this.link = null; 
		}
		
		//non-static methods 
		public void setData(T data) {
			this.data = data; 
		}
		
		public T getData() {
			return this.data; 
		}
		
		public void setLink(Node<T> otherNode) {
			this.link = otherNode; 
		}
		
		public Node<T> getLink() {
			return this.link; 
		}
		
	}

}

package NodeBasedList;

public class NodeBasedListDemo {
	
	public static void main(String[] args) {
		NodeBasedList<String> favoriteBandList = new NodeBasedList<>(); 
		favoriteBandList.add("Beatles");
		favoriteBandList.add("Big Time Rush");
		favoriteBandList.add("The Spice Girls");
		
		System.out.println(favoriteBandList.remove("The Spice Girls")); 
		
		System.out.println(favoriteBandList.toString()); 
		
	}

}
=====================================================================================================================================================
