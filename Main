
Abstract Data Types:

Primitive Data Types:
========================================================================================================================================================
These are built-in data types wihthin the language - class data types are data-types we create. 
int, double, boolean, char. 
========================================================================================================================================================

Class Data Types:
========================================================================================================================================================
Fruit, Car, Television, Album 
(They represent real-world things that are tangible in nature)

Abstract Data Types:
========================================================================================================================================================
'Abstract'means something that isn't tangible or concrete - it only exists as an idea. 
For instance, religion, justice, etc. 
Abstract Data Types are defined by how they work, rather than how they are defined. 

Formal definition: An Abstract Data Type is an entity that is defined by how it functions
and not by how it is implemented or constructed. 
========================================================================================================================================================


Interfaces 
========================================================================================================================================================
- Interfaces are a set of requirements for a class to implement. These requirements are listed or represented as method headings). The Interface will include a set of method headers that a class must provide an implementation for.
- An interface will not have constructors or instance variables 
- The headers will consist of an access modifier, a return type, the name of the method, and any parameters.  
- A class that chooses to 'implement' an interface must implement all method headings listed in the interface. 
- The idea of an interface is analogous to a contract in law, where two or more parties agree to be part of an agreement that must be followed. 
- In the same way, a class is a blueprint for an object, and an interface is a blueprint for a class. 
- There are now 3 levels: An interface, a class, and an object. 
- Class that chooses to implement an interface will use the keyword 'implements', E.g, 'ArrayBasedStack implements StackInterface' 

========================================================================================================================================================
 
Exception Handling
========================================================================================================================================================
- An exception is an occurance of an unusual event. 
- The exceptions are represented as special objects that inherit from the in-built 'Exception' class. 
- Exceptions do not have instance variables or methods - they merely have 1-2 constructors 
- The first constructor is a non-parameter constructor that makes a call to super()
- The second constructor is a paramter-based constructor that recieves a 'String message' variable 
  and the call to super() accepts message by super(message) 
- We may 'throw' and 'catch' exceptions - where 'throwing' an exception creates an object of the Exception
  class, and 'catching' the exception is handling the exceptional case.
- Exceptions don't have instance variables because we know what is happening when the throwing an exception
  and there is no need to store additional information. 
- Creating an exception will create a new Exception object that is polymorphic. 
- For instance, a StackFullException will be of type Object, Throwable, Exception, and
  itself - StackFullException. 
  
 ==>> Example of Exception:<<==

public class StackFullException extends Exception { //must extend 'Exception' 
	
	//no instance variables 
	public StackFullException() {
		super(); //call to the Exception class constructor - as such, the class does not have instance variables  
	}
	
	//overloaded constructor 
	public StackFullException(String message) {
		super(message); //call to overloaded Exception class that accepts 'message'...  
	}
	
	//has no non-static methods 
}

==>> Example of Method that throws an Exception <<==

//Methods that 'may' throw an exception will have 'throws ExceptionName' 
//Within the body, 'throw new ExceptionName(MessageOfChoice) 

public void pop() throws StackEmptyException { 
		if(top == -1) {
			throw new StackEmptyException("Stack is Empty"); 
		} 
		else {
			stack[top] = null; 
			top--; 
		}
}

========================================================================================================================================================


  
Heirarchy of Exceptions 
========================================================================================================================================================
Since an Exception is a child of Throwable, and since our Exceptions inherit from Exception, we can throw our Exceptions. 
[Object] -> [Throwable] -> [Exception] -> Any Exception you might create (StackEmptyException/StackFullException)
========================================================================================================================================================

========================================================================================================================================================

         Equals Methods
	/*
	 * public boolean equals(Object otherObject) {
	 * 	  boolean areTheyEqual = false; 
	 *   if(otherObject == null && otherObject instanceof [MoreSpecificTypeOfObject]) {
	 *   	check for equality of each instance variable. Nesting depth approach is the best move here. 
	 *      (if it checks out, areTheyEqual = true);  
	 *   }
	 *   return areTheyEqual
	 * }
	 * 
	 */
========================================================================================================================================================



Stack ADT

========================================================================================================================================================
 ==>> ArrayBasedStack.java <<== 

- Items are added to the top of the stack, and items are removed from the top of the stack 
  such that the last item added to the stack will be the first item removed from the stack 
- The Stack ADT is LIFO: Last In First Out 
- Stack ADTs usually have the following: Push, Pop, and Peek.

public class ArrayBasedStack<T> extends Object implements StackInterface<T> {
	//instance variables 
	private int top; 
	private  T[] stack; //we could have said 'Object stack' here but that would allow for different data-types to enter the stack. So, instead.. we choose 'T'  
	
	public ArrayBasedStack() {
		super(); 
		top = -1; 
		stack = (T[])new Object[100]; //again, if we just just did Object[100] - we could have multiple object types within our stack - so we type-cast it to the T we want. 
	}
	
	public ArrayBasedStack(int sizeOfStack) {
		super(); //still making call to super() <- must come first 
		top = -1; //top is still given default value 
		//checking for valid sizeOfStack 
		if(sizeOfStack > 0) {
			stack = (T[])new Object[sizeOfStack];
		}
		else {
			stack = (T[])new Object[100];
		}
	}
	
	public void push(T item) throws StackFullException {
		/*
		 *pushing implies we should check if the stack is full (it being empty / not full are both positive cases)
		 *we know that the total number of indices contained within an array of size X should be X-1. (0 through X-1) (Eg. Array length 10 should have 0-9 indices).
		 *So, if the length is 10 and the highest index is 9, we are in bounds for an array of length 10. But, if the index reference touches 10, then it's OOB. 
		 *The array should thus be considered 'full' if the top index (which keeps track of where to populate) is equal to the last index in an array of length X, which would be X-1. 
		*/
		if(top == stack.length-1) { 
			throw new StackFullException("Stack is full"); 
		} 
		else {
			//move top up by one so that it can be positioned at a vacant space 
			//then within that vacant space, store 'item' that was passed in by user 
			top++; 
			stack[top] = item; 
		}	
	}
	
	public void pop() throws StackEmptyException {
		//Cannot pop from an empty stack - so, we will say if top == -1, then throw exception; else, go through removing process. 
		//CSC223 has it such that if top >= 0 then it's safe to remove; otherwise throw exception. 
		if(top == -1) {
			throw new StackEmptyException("Stack is Empty"); 
		} 
		else {
			stack[top] = null; 
			top--; 
		}
	}
	
	public T peek() throws StackEmptyException {
		//recall, this is condition for 'empty'... so if it's empty, through exception, else return stack[top]... with that said
		//CSC223 has this as if(top >= 0) then return stack[top], else throw exception. 
		if(top == -1) {
			throw new StackEmptyException(); 
		}
		return stack[top]; 		
	}
	
	
	//this is just for demonstration but we can have isEmpty isFull methods -> this method can replace condition in push
	public boolean isFull() {
		return(top == stack.length-1); 
	}
	
	//this is just for demonstration, but we can have isEmpty method -> this method can replace condition in pop
	public boolean isEmpty() {
		return(top == -1); 
	}
	
	public void print() { 
		int elements = top+1; 
		for(int i = 0; i < elements; i++) {
			System.out.println(stack[i]); 
		}
	}
	
	/*
	 * Alternate version of pop()
	 * 
	 * public void pop() throws StackEmptyException {
	 *    if(top >= 0) {
	 * 	    stack[top] = null; 
	 * 	    top--;
	 *    else {
	 * 	     throw new StackEmptyException("Pop attempted on an empty stack!"); 
	 * 	  }
	 *   }
	 * }
	 */
	
	/*
	 * Alternate version of push()
	 * 
	 * public void push(T item) throws StackFullException {
	 * 
	 * 		if(top < stack.length - 1) {
	 * 			top++; 
	 * 			stack[top] = item; 
	 * 		}
	 * 		else {
	 * 			throw new StackFullException("Push attempted on a full stack"); 
	 * 		}
	 * }
	 */
	
	
	/*
	 * Alternate version of peek() 
	 * 
	 * public T peek(T item) throws StackEmptyException {
	 * 		 
	 * 		T value = null; 
	 * 			
	 * 		if(top >= 0) {
	 * 			
	 * 			value = stack[top]; 
	 * 			
	 * 		}
	 * 		else {
	 * 			throw new StackEmptyException();
	 * 		}
	 * 		return value; 
	 * }
	 */
}


==>> StackInterface.java <<==
package Stack;

public interface StackInterface<T> {

	//if the stack is full, this method will throw 'StackFullException'; otherwise, it places the item it receives on-top of the stack. 
	public void push(T item) throws StackFullException;  
	
	//if the stack is empty, this method will throw 'StackEmptyException'; otherwise it will remove an item from the top of the stack 
	public void pop() throws StackEmptyException; 
	
	//if the stack is empty, this method will throw 'StackEmptyException'; otherwise, it will return the item on the top of the stack. 
	public T peek() throws StackEmptyException; 
	
}

==>> StackFullException.java <<==

/*
 * Classes that are built around 'Exceptions' extend (inherit) from the 'Exception class'
 * Typically, Exception classes do not have any instance variables. 
 * They typically have two constructors - one that accommodates a message, and one that doesn't. 
 * Both constructors will make a call the the parent's constructor which is 'Exception'. 
 */


  =>> StackFullException.java <<=
  
public class StackFullException extends Exception { //must extend 'Exception' 
	
	//no instance variables 
	public StackFullException() {
		super(); //call to the Exception class constructor - as such, the class does not have instance variables  
	}
	
	//overloaded constructor 
	public StackFullException(String message) {
		super(message); //call to overloaded Exception class that accepts 'message'...  
	}
	
	//has no non-static methods 

}


  =>> StackEmptyException.java <<=

/*
 * Classes that are built around 'Exceptions' extend (inherit) from the 'Exception class'
 * Typically, Exception classes do not have any instance variables. 
 * They typically have two constructors - one that accommodates a message, and one that doesn't. 
 * Both constructors will make a call the the parent's constructor which is 'Exception'. 
 */


public class StackEmptyException extends Exception {
	
	public StackEmptyException() {
		super(); 
	}
	
	public StackEmptyException(String message) {
		super(message); 
	}
	
}

==>> StackDemo.java Version 1 <<== 
//When we run into StackFullException, we will not execute any code afterwards and executation will halt.
//If we want the code to run, we must surround code that might breed specific exceptions in their own 
//try catch. 
public class StackDemo {

	public static void main(String[] args) {
		ArrayBasedStack<String> stack = new ArrayBasedStack<>(3);

		try {
			stack.push("Dexter");
			stack.push("Better Call Saul");
			stack.push("Game of Thrones");
			stack.push("House of Cards"); // this will not get added to the stack but the program will still continue
		
			System.out.println("Top of stack: " + stack.peek());
			System.out.println("Now popping..");
			stack.pop();

			System.out.println("Top of stack: " + stack.peek());
			System.out.println("Now popping..");
			stack.pop();

			System.out.println("Top of stack: " + stack.peek());
			System.out.println("Now popping..");
			stack.pop();

		}
		catch(StackFullException e1) {
			System.out.println(e1.getMessage()); 
		}
		catch(StackEmptyException e2) {
			System.out.println(e2.getMessage());
		}

	}
}
========================================================================================================================================================


Lecture 14:

Static Allocation of Memory:
========================================================================================================================================================
- Limitation of using an array-based stack implementation is that the implementation uses 
 'Static Memory Allocation', in that once the size of the array is declared (by either the program or
  the user) then it cannot be increased in the event the stack is full. We throw an exception; however, 
  we cannot accomodate more items. 
 - We should not choose to store 1000 or 10mil for our size because then we are consuming memory 
   that might not be used. 
 - Static Allocation of Memory involes or happens when the amount of memory that is reserved for use does not
   change as the program executes. The amount of memory that is reserved is either determined when the
   program is written when the memory is allocated, but does not change from that point forward. 
 - Dynamic Memory Allocation: [the process of assigning the memory space during the execution time or the run time] 
 - Static Memory Allocation: [memory is allocated for declared variables by the compiler]

Dynamic Allocation of Memory:
========================================================================================================================================================
- Dynamic Allocation of Memory involves or happens when the amount of memory that is reserved for changes
  as the program executes. 
- The amount of memory that is allocation can increase or decrease as needed by the program. 
- Dynamic Allocation of Memory is facilated by an Object called a 'Node' which has comprises of 
  a piece of data and a reference to the next Node. So, as such, you can always increase the size by 
  adding and chaining Nodes. 
  
 >>> The Node Class <<<
========================================================================================================================================================
 
 public class Node<T> {

    //instance variables
    private T data;
    private Node<T> link; //reference to an object of the Node<T> class

    //constructor that receives data
    //the data passed in will refer to the global data field
    //Every node created floats in memory at first, and link is not referring to anything.
    public Node(T data) {
        this.data = data;
        link = null;
    }

    //non-static methods
    public void setData(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

    public void setLink(Node<T> otherNode) {
        this.link = otherNode;
    }

    public Node<T> getLink() {
        return link;
    }

}

==>> NodeDemo 1 <<== 

public class NodeDemo {

    public static void main(String[] args) {

        //firstNode & secondNode are references to a Node object
        // firstNode -> [data: Dune | link: secondNode]
        //secondNode -> [data: X | link: null]

        Node<String> firstNode = new Node<String>("Dune");
        Node<String> secondNode = new Node<String>("1984");

        firstNode.setLink(secondNode);

        //prints 1984
        System.out.println(firstNode.getLink().getData());
    }
}

==> NodeDemo 2 <==
public class NodeDemo {

    public static void main(String[] args) {

        //firstNode & secondNode are references to a Node object
        // firstNode -> [data: Dune | link: secondNode]
        //secondNode -> [data: X | link: null]

        Node<String> firstNode = new Node<String>("Dune");
        Node<String> secondNode = new Node<String>("1984");
        Node<String> thirdNode = new Node<>("Animal Farm");
        firstNode.setLink(secondNode);
        secondNode.setLink(thirdNode);

        //Activity: Loop through all items and print content. 

        Node<String> current = firstNode;

        while(current != null) {
            System.out.println(current.getData());
            current = current.getLink();

        }
    }
}

========================================================================================================================================================
Stack Implemented with Nodes:
/*
 * The Stack with Links - adding a new item goes above item 1 and top moves up
 * 
 * 	    [top] ===>   	[ item 1 ]
 * 				   ||	
 * 				   ||		
 * 				   \/
 * 				[ item2 ]
 * 
 * 				   ||	
 * 				   ||		
 * 				   \/
 * 				[ item 3]
 * 				   ||
 * 				   ||
 * 				   \/
 * 				
 */	

>> NodeBasedStack.java << 
public class NodeBasedStack<T> implements UnboundedStackInterface<T> {

	private Node<T> top;

	public NodeBasedStack() {
		top = null;
	}

	@Override
	public void pop(T item) throws StackEmptyException {

		if (top == null) {
			throw new StackEmptyException("Stack is empty");
		} else {
			top = top.getLink();
		}
	}

	@Override
	public String peek() {
		if (top == null) {
			return "Stack is Empty";
		} else {
			return top.getData().toString();
		}
	}

	@Override
	public void push(T item) {
		Node<T> currentNode = new Node<T>(item);

		if (top == null) {
			top = currentNode;
		} 
		else {
			currentNode.setLink(top);
			top = currentNode;
		}
	}

	public void print() {
		Node<T> current = top;

		while (current != null) {
			System.out.println(current.getData());

			current = current.getLink();
		}
	}

}

>> StackInterface.java << 

public interface StackInterface<T> {
	
	public void push(T item) throws StackFullException; 
	
	public void pop(T item) throws StackEmptyException;
	
	public String peek(); 

}

>> UnboundedStackInterface <<

public interface UnboundedStackInterface<T> extends StackInterface<T> {
	
	
	/*
	 * Since UnboundedStackInterface extends StackInterface; all of the 
	 * method headers defined StackInterface are available and known to know
	 * UnboundedStackInterface. We don't need to rewrite the method headers
	 * that we want within UnboundedStack that are within StackInterface, 
	 * but we may Override a header we want to change. 
	 * For instance, StackInterface has a 'push' method that throws 
	 * a StackFullException. Our unbounded stack can never be full so we
	 * want to have a 'push' header in our UnboundedStackInterface that
	 * does not throw this exception. 
	 */
	
	public void push(T item); 

}

>> Node.java <<

public class Node<T> {
	
	//instance variables
    private T data;
    private Node<T> link; //reference to an object of the Node<T> class

    //constructor that receives data
    //the data passed in will refer to the global data field
    //Every node created floats in memory at first, and link is not referring to anything.
    public Node(T data) {
        this.data = data;
        link = null;
    }

    //non-static methods
    public void setData(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

    public void setLink(Node<T> otherNode) {
        this.link = otherNode;
    }

    public Node<T> getLink() {
        return link;
    }

}

>> StackEmptyException << 
public class StackEmptyException extends Exception {

	public StackEmptyException() {
		super(); 
	}
	
	public StackEmptyException(String message) {
		super(message); 
	}
	
}

>> StackFullException <<
public class StackFullException extends Exception {

		public StackFullException() {
			super(); 
		}
		
		public StackFullException(String message) {
			super(message); 
		}
}

>> UnboundedStack.java <<
public class UnboundedStackDemo {
	
	public static void main(String[] args) {
		
		NodeBasedStack<String> stack = new NodeBasedStack<String>();
		stack.push("Jacob");
		stack.push("Tony");
		stack.push("Matthew");
		
		System.out.println(stack.peek());
		
		
	}
}
========================================================================================================================================================

Queue Abstract Data Type:
- A queue is when items are added to the rear of the queue, but items are removed from the
front of the queue. The queue operates on a FIFO basis - First In First Out. 
The way a Queue works is analogous to a way a line works - those first are the first out, and those
last are the last out. 

- When the first item is added to the queue, it is both the 'front' and the 'rear' 

- [item 1] [item 2] [item 3] 
    \ front 	 	\ rear 
    
- Enqueue adds to the back of the queue 
- Dequeue removes from the front of the queue 

=>> QueueInterface.java <<==

public interface QueueInterface<T> {
	
	public void enqueue(T value) throws QueueFullException; 
	
	//removes and returns item at the front of the quee
	//otherwise throws QueueEmptyException
	public T dequeue() throws QueueEmptyException; 

	
	//string representation of front of queue 
	public String look(); 	
}

=>> QueueFullException <<== 
public class QueueFullException extends Exception {

	public QueueFullException() {
		super(); 
	}
	
	public QueueFullException(String message) {
		super(message); 
	}
	
}

==>> QueueEmptyException.java <<== 

public class QueueEmptyException extends Exception {
	
	public QueueEmptyException() {
		super(); 
	}
	
	public QueueEmptyException(String message) {
		super(message); 
	}

}

==>> ArrayBasedQueue.java <<==
package QueueProgram;

/*
 * if rear == queue.length-1 will mean that the rear has reached the last element
 * which is referenced by the last index in the array. 
 * 
 * If that is the case, we want rear to equal 0, otherwise just move forward. 
 */


public class ArrayBasedQueue<T> implements QueueInterface<T> {

	private T[] queue;
	private int front;
	private int rear; 
	private int numberOfItems; 
	
	public ArrayBasedQueue() {
		this.queue =  (T[]) new Object[10];
		front = 0; 
		rear = 0; 
		numberOfItems = 0; 
	}
	
	public ArrayBasedQueue(int size) {
		if(size < 0) {
			this.queue =  (T[]) new Object[10];
		}
		else {
			this.queue =  (T[]) new Object[size];
		}
	}
	
	
	@Override
	public void enqueue(T item) throws QueueFullException {
		/*
		 * Since the length = items in an array
		 * if items = length, then queue is full. 
		 * 
		 * would be if(numberOfItems < queue.length) then 
		 * queue[rear] = item; 
		 * rear++; 
		 * numberOfItems++ 
		 * but we want to wrap rear around 
		 */
		
		if(numberOfItems < queue.length) {
			queue[rear] = item;
			numberOfItems++; 
			/*
			 * We added an item to rear since it's valid 
			 * But, if rear is now on the last element, wrap it around to front. 
			 * Otherwise status quo, add one to rear. 
			 */
			if(rear == queue.length-1) {
				rear = 0; 
			}
			else {
				rear++;
			}
			
		}
		else {
			throw new QueueFullException("Cannot enqueue on full queue");
		}
	}
	
	int counter = 0; 
	public void print() {
		
		System.out.println(counter + " iteration "); 
		System.out.println("======================");
		for(int i = 0; i < queue.length; i++) {
			System.out.println(queue[i]);   
		}
		System.out.println("======================");
		counter++; 
	}
	
	public void printLast() {
		System.out.println(queue[rear].toString());
	}

	@Override
	public T dequeue() throws QueueEmptyException {
		T value = null; 
		//judge if queue is empty
		if(numberOfItems == 0) {
			throw new QueueEmptyException("Queue is empty"); 
		}
		else {
			value = queue[front];  
			queue[front] = null; 
			front++;
			numberOfItems--; 
		}
		return value; 
	}

	@Override
	public String look() {
		String frontItem = ""; 
		if(numberOfItems > 0) {
			frontItem = queue[front].toString(); 
		}
		else {
			System.out.println("Cannot look on empty queue"); 
		}
		return frontItem; 
	}

}

==>> QueueDemo.java <<==
package QueueProgram;

import java.util.Scanner;

public class QueueDemo {

	public static void main(String[] args) {

		Scanner keyboard = new Scanner(System.in); 
		
		QueueInterface<String> queue = new ArrayBasedQueue<String>(5);

		int option;
		do {
			
			System.out.println("Press 1 to add a song to the playlist"); 
			System.out.println("Press 2 to remove a song from the playlist"); 
			System.out.println("Press 3 to look at song in front"); 
			System.out.println("Press 4 to end the program");
			option = keyboard.nextInt(); 
			keyboard.nextLine(); 
			
			if (option == 1) {
				System.out.println("Enter name of song: "); 
				String song = keyboard.nextLine(); 
				
				try {
					queue.enqueue(song);
				} 
				catch (QueueFullException e) {
					System.out.println(e.getMessage()); 
				}
			}
			else if (option == 2) {
				try {
					System.out.println(queue.dequeue());
				} 
				catch (QueueEmptyException e) {
					System.out.println(e.getMessage()); 
				} 
			}
			else if (option == 3) {
				System.out.println(queue.look()); 
			}
			else if (option == 4) {
				System.out.println("Thank you."); 
			}
			else {
				System.out.println("Invalid option entered"); 
			}


		} while (option != 4);

	}

}

=======================================================================================================================================================

Node.java

public class Node<T> extends Object {
	
	private T data;
	private Node<T> link; 
	
	public Node(T data) {
		super(); 
		this.data = data; 
		this.link = null; 
	}
	
	public void setLink(Node<T> otherNode) {
		this.link = otherNode;
	}
	
	public T getData() {
		return this.data; 
	}
	
	public Node<T> getLink() {
		return link; 
	}

}


public class QueueEmptyException extends Exception {
	
	public QueueEmptyException() {
		super(); 
	}
	
	public QueueEmptyException(String message) {
		super(message); 
	}
	
}

public class QueueFullException extends Exception {
	
	public QueueFullException() {
		super(); 
	}
	
	public QueueFullException(String message) {
		super(message); 
	}

}

public interface QueueInterface<T> {
	
	public void enqueue(T item) throws QueueFullException; 
	
	public T dequeue() throws QueueEmptyException; 
	
	public String look(); 

}


public interface UnboundedQueueInterface<T> extends QueueInterface<T>{

	/*
	 * These were in the QueueInterface 
	 * 
	 * 	public void enqueue(T item); 
	 *
	 *	public T dequeue() throws QueueEmptyException; 
	 *
	 *	public String look(); 
	 * 
	 * dequeue and look are available in the same way they are noted in QueueInterface, but since we have added an implementation for enqueue - 
	 * it overrides the default implementation. Namely, in this case, enqueue 
	 * 
	 */
	
	
	public void enqueue(T item); 

}

package NodeBasedQueue;

public class NodeBasedQueue<T> extends Object implements UnboundedQueueInterface<T>{

	private Node<T> front; 
	private Node<T> rear; 
	//private int numberOfItems; 
	
	
	public NodeBasedQueue() {
		super(); 
		front = null; 
		rear = null; 
		//this.numberOfItems = 0; 
	}
	
	@Override
	public T dequeue() throws QueueEmptyException {
		if(isEmpty()) {
			throw new QueueEmptyException("Dequeue attempted on empty queue"); 
		}
		else {
			T frontItem = front.getData(); 
			front = front.getLink(); 
			//special case when we remove all items - front points to null but rear does? So update rear as well. 
			if(front == null) {
				rear = null; 
			}
			//numberOfItems--; 
			return frontItem; 
		}
	}
	
	public boolean isEmpty() {
		return(front == null && rear == null); 
	}

	@Override
	public String look() {
		String frontItem = ""; 
		if(isEmpty()) {
			frontItem = "Queue is Empty"; 
		}
		else {
			frontItem = front.getData().toString(); 
		}
		return frontItem; 
	}

	@Override
	public void enqueue(T item) {
		
		Node<T> currentNode = new Node<T>(item); 
		
		//can never be full
		if(front == null && rear == null) {
			front = currentNode; 
			rear = currentNode; 
			//numberOfItems++; 
		}
		else {
			rear.setLink(currentNode);
			rear = currentNode; 
			//numberOfItems++; 
		}
		
	}
}

public class NodeBasedQueueDemo {
	
	public static void main(String[] args) {
		NodeBasedQueue<String> waitList = new NodeBasedQueue<String>(); 
		
		System.out.println(waitList.look()); 
		
		waitList.enqueue("Jack");
		waitList.enqueue("Jill");
		waitList.enqueue("Joe");
		
		System.out.println(waitList.look()); 
		
		
		try {
			System.out.println("Removed from front: " + waitList.dequeue());
			System.out.println(waitList.look()); 
			System.out.println("Removed from front: " + waitList.dequeue());
			System.out.println(waitList.look()); 
			System.out.println("Removed from front: " + waitList.dequeue());
			System.out.println(waitList.look()); 
		} 
		catch (QueueEmptyException e) {
			System.out.println(e.getMessage()); 
		} 
		
		System.out.println(waitList.look()); 

	}

}

=========================================================================================================================================================

List:

package ListProject;

public interface ListInterface<T> {
	
	//adds item to list 
	public void add(T item); 
	
	//if item exists, remove and return true; else do opposite. 
	public boolean remove(T item); 
	
	public boolean find(T item);

	
}

package ListProject;

public class ArrayBasedList<T> implements ListInterface<T> {

	private int numberOfItems;
	private T[] list;

	public ArrayBasedList() {
		list = (T[]) new Object[5];
		numberOfItems = 0;
	}

	public ArrayBasedList(int size) {
		numberOfItems = 0;
		if (size > 0) {
			list = (T[]) new Object[size];
		} else {
			list = (T[]) new Object[5];
		}
	}

	@Override
	public void add(T item) {

		if (numberOfItems < list.length) { // numberOfItems < list.length means list isn't full, equal case would go to
											// else.
			list[numberOfItems] = item;
			numberOfItems++;
		} else {
			// This is the if we are full case. We create a list that is double the length,
			// and then have new list be old list.
			T[] largerList = (T[]) new Object[list.length * 2];
			for (int i = 0; i < list.length; i++) {
				largerList[i] = list[i];
			}
			// copy item intended into new list - remember, 'numberOfItems' serves as our
			// index as well.
			largerList[numberOfItems] = item;
			numberOfItems++;
			list = largerList; // update reference
		}
	}

//	public boolean find(T item) {
//		/*
//		 * Using while loop - allows us to stop as soon as we hit a case where item is
//		 * found. Only do index < numberOfItems and not index < list.length since we
//		 * only want to check area that is filled.
//		 */
//		boolean found = false;
//		int index = 0;
//
//		while (!found && index < numberOfItems) {
//			if (list[index].equals(item)) {
//				found = true;
//			} else {
//				index++;
//			}
//		}
//		return found;
//	}
	
	
	public boolean find(T item) {
		boolean found = false; 
		int index = locate(item); 
		if(index != -1) {
			found = true; 
		}
		return found; 
	}
	
	public String toString() {
		String toReturn = ""; 
		for(int i = 0; i < numberOfItems; i++) {
			toReturn  = toReturn + list[i].toString() + "\n";
		}
		return toReturn; 
	}

//	public boolean remove(T item) {
//		boolean found = find(item);
//		boolean removed = false;
//
//		if (found == true) {
//
//			int index = 0;
//
//			while (removed == false && index < numberOfItems) {
//				if (list[index].equals(item)) {
//					list[index] = null;
//					removed = true;
//					numberOfItems--;
//
//					// now we're going to do something different here - list is [x][x][x][x] but
//					// when we remove, like with [x][x][][x][x] well
//					// since we don't care about order we can take last item and drop it into the
//					// newly created vacant space
//					list[index] = list[numberOfItems];
//					list[numberOfItems] = null;
//				} else {
//					index++;
//				}
//			}
//		}
//
//		return removed;
//	}
	
	
	public boolean remove(T item) {
		int index = locate(item); 
		boolean removed = false; 
		if(index != -1) {
			list[index] = null;
			numberOfItems--;
			list[index] = list[numberOfItems];
			list[numberOfItems] = null;
			removed = true;
		}
		return removed; 
		
	}
	

	// helper method - private. Is not a part of the interface, so private helper
	// methods can be in class even if it isn't defined in interface
	//this is an implemenative detail 
	private int locate(T item) {
		int index = 0;
		boolean found = false;

		while (!found && index < numberOfItems) {
			if (list[index].equals(item)) {
				found = true;
			} else {
				index++;
			}
		}

		if(found == false) {
			index = -1; 
		}
		
		//otherwise index would be holding valid location since index never got a chance to update after initial find 
		return index; 

	}

}


package ListProject;

import java.util.Scanner;

public class ListDemo2 {
	
	public static void main(String[] args) {
		Scanner keyboard = new Scanner(System.in);
		
		ListInterface<String> myList = new ArrayBasedList<String>(2); 
		
		int option; 
		do {
			System.out.println("Press 1 to add an item to the list"); 
			System.out.println("Press 2 to remove an item from the list");
			System.out.println("Press 3 to find an item from the list");
			System.out.println("Press 4 to end the program"); 
			option = keyboard.nextInt();
			keyboard.nextLine(); 
			
			if(option == 1) {
				System.out.println("Enter item"); 
				String input = keyboard.nextLine();
				myList.add(input); 
			}
			else if(option == 2) {
				System.out.println("Enter item you would like to remove"); 
				String input = keyboard.nextLine();
				myList.remove(input); 
			}
			else if(option == 3) {
				System.out.println("Enter item to remove");
				String input = keyboard.nextLine();
				if(!myList.find(input)) {
					System.out.println("Item not found"); 
				}
				else {
					System.out.println("Item was found!"); 
				}
			}
			else if(option == 4) {
				System.out.println("Thank you for using the program!"); 
			}
			else {
				System.out.println("Please enter a valid option"); 
			}
			System.out.println("LIST NOW: "); 
			System.out.println(myList.toString()); 
		}while(option != 4);
		
	}

}
=====================================================================================================================================================

NodeBasedList:

package NodeBasedList;

public interface ListInterface<T> {
	
	public void add(T item); 
	
	public boolean remove(T item); 
	
	public boolean find(T item); 
	
	public String toString(); 

}

package NodeBasedList;

public class NodeBasedList<T> extends Object implements ListInterface<T> {
	
	private Node list; //reference to node object 
	
	public NodeBasedList() {
		super(); 
		this.list = null; 
	}

	@Override
	public void add(T item) {
		Node<T> currentNode = new Node<>(item); 
		if(list == null) {
			list = currentNode; 
		}
		else {
			//there is no order! no need to traverse and put element to head. Just do a prepend operation. 
			currentNode.setLink(list);
			list = currentNode; 
		}
		
	}
	
	private Node<T> locate(T item) {
		Node<T> toReturn = null; 
		boolean found = false; 
		Node<T> current = list; 
		while(current != null) {
			if(current.getData().equals(item)) {
				toReturn = current; 
				break; 
			}
			current = current.getLink(); 
		}
		return toReturn; 
	}
	
	public boolean find(T item) {
		boolean found = false; 
		//since locate(T item) gives a Node, you cannot store it in a boolean value 
		Node<T> current = locate(item); 
		if(current != null) {
			//we know it was found 
			found = true; 
			
		}
		return found; 
	}
	
	
	
	public String toString() {
		String toReturn = ""; 
		Node<T> current = list; 
		while(current != null) {
			toReturn = toReturn + current.getData().toString() + "\n"; 
			current = current.getLink(); 
		}
		return toReturn; 
		
	}

	@Override
	public boolean remove(T item) {
		boolean verdict = false; 
		while(list != null && list.getData().equals(item)) {
			list = list.getLink(); 
		}
		
		Node<T> prev = null; 
		Node<T> current = list; 
		
		while(current != null) {
			if(current.getData().equals(item)) {
				prev.setLink(prev.getLink().getLink());
			}
			else {
				prev = current; 
			}
			current = current.getLink(); 
		}
	
		return verdict; 
	}
	
	
It's like the remove on LC Remove Linked List Elements	
--------------------------------------------------------
	class Solution {
    public ListNode removeElements(ListNode head, int val) {
        
        while(head != null && head.val == val) {
            head = head.next; 
        }
        
        ListNode n1 = head; 
        ListNode prev = null; 
        
        while(n1 != null) {
            if(n1.val == val) {
                prev.next = n1.next; 
            }
            else {
                prev = n1; 
            }
            n1 = n1.next; 
        }
        return head; 
        
    }
}
-----------------------------------------------------
	

	
	/*
	 * Can create personal 'Node' class within NodeBasedList - this is called an 'inner class' 
	 * which is completely contained inside NodeBasedList. 
	 * For inner-classes, while you don't have access to T data and Node<T> link because they are private
	 * you still have access to public methods (like setData and getData and setLink)
	 */
	
	private class Node<T> {
		//instance variables (same as before, T data, and Node link 
		private T data; 
		private Node<T> link; 
		
		public Node(T data) {
			this.data = data; 
			this.link = null; 
		}
		
		//non-static methods 
		public void setData(T data) {
			this.data = data; 
		}
		
		public T getData() {
			return this.data; 
		}
		
		public void setLink(Node<T> otherNode) {
			this.link = otherNode; 
		}
		
		public Node<T> getLink() {
			return this.link; 
		}
		
	}

}

package NodeBasedList;

public class NodeBasedListDemo {
	
	public static void main(String[] args) {
		NodeBasedList<String> favoriteBandList = new NodeBasedList<>(); 
		favoriteBandList.add("Beatles");
		favoriteBandList.add("Big Time Rush");
		favoriteBandList.add("The Spice Girls");
		
		System.out.println(favoriteBandList.remove("The Spice Girls")); 
		
		System.out.println(favoriteBandList.toString()); 
		
	}

}
========================================================================================================================================================

Recursion:
- Iteration is repetition of some part of a program implemented by using loops (while, do/while, for-loop) 
- The process in which a function calls itself directly or indirectly is called "recursion" and the corresponding function is called a recursive function.
- a recursive function will call itself multiple times - each call simplifies the problem - until it eventually reaches a 'base case', where the 
  recursive nature of the function terminates. 
- The call stack is what a program uses to keep track of method calls. The call stack is made up of stack framesâ€”one for each method call.
- Each method is a method call. These method calls are placed on the callstack. 
- Hence, recursion is underpinned by the STACK ADT. 
  
 

===>> EXAMPLE 1 <<=== 
public class NodeBasedListDemo {
	
	public static void main(String[] args) {
		countDown(3); 
	}
	
	public static void countDown(int num) {
		if(num > 0) {
			System.out.println(num); 
			countDown(num-1); 
		}
	}

}

/*
Call one: 
countDown(3)
=> if(num > 0) TRUE 
=> print num (3) 
=> call countDown(int num) function on num-1 so countDown(num-1) = countDown(2) 


Call two:
=> if(num > 0) TRUE 
=> print num (2) 
=> call countDown(int num) function on num-1 so countDown(num-1) = countDown(1) 
 
Call three:
countDown(1)
=> if(num > 0) TRUE 
=> print num (1) 
=> call countDown(int num) function on num-1 so countDown(num-1) = countDown(0)

Call four:
countDown(1)
=> if(num > 0) FALSE 

terminated 
*/

===>> EXAMPLE 2 <<===
public class NodeBasedListDemo {
	
	public static void main(String[] args) {
		
		int result = factorial(4); 
		System.out.println(result); 

		
	}
	
	/*
	 * 
	 * This is the pattern for finding X! - where is X is any positive number (including 0) 
	 * 4! = 4 * 3 * 2 * 1
	 * 
	 * 3! = 3 * 2 * 1 
	 * 
	 * 2! = 2 * 1
	 * 
	 * 1! = 1 
	 * 
	 * 0! = 1 
	 * 
	 * We can therefore see that
	 * 
	 * 4! = 4 * 3! 
	 * 3! = 3 * 2! 
	 * 2! = 2 * 1! 
	 * 1! = 1 
	 * 0! = 1 
	 * 
	 * So, for any given accepted number in the function, we take that number and multiply it by 
	 * the the factorial of the number-1. 
	 * Specifically, it would be: num * factorial(num-1)
	 * 
	 * The base case is when the number equals 0 - and since 0! = 1, when the method eventually 
	 * lowers 'num' to 0, we can return 1. 
	 */
	
	
	public static int factorial(int num) {
		if(num == 0) {
			return 1; 
		}
		return num * factorial(num-1); 
	}

}
========================================================================================================================================================


Tree Abstract Data Type (ADT):
- A Tree is a nonlinear abstract data type. 
- Linear Abstract data type is one where each item in the ADT has at most one item before it (predecessor) and one after is (successor) 
- Stacks/Queues/Linked Lists/Lists are linear ADTS
- Tree ADT each item will have at most one item before it (predecessor) but it can have more than one(successor) 
- Every time an item is added to the tree ADT it is made a successor to one of the existing items in the tree except in the case of the first item 
  which is referred to as the root of the tree. 
- a Tree ADT has a 'root' and children (successor) 'branch off' from the 'root' 
- Leaves are 'nodes' or successors to the root that do not have 'children' 

Binary Trees 
- Trees with a particular restriction: 
- Each item can have at most two successors (children) - so, after you have two children (successors) to a root, children must be imposed on the
  two successors of the root. 
- Each child is a root of its own tree. 

Binary Search Tree
- Note: Binary Trees are different than Binary Search Trees
- a Binary Search Tree is a tree that has at most two children/each node is a root of its own subtree.. AND all nodes to the RIGHT of the root are 
  greater in value and all nodes to the left of the root are less than the root's value. 

Determining where a value should go in a BST
- Judge whether the value is > or < the root. If less, go left. If more, go right. Keep doing this process for each node until the one you want
entered find its place 
       
      40 
    13  45 
   8 26 42 98
             99

Efficency of BST:
For a list, you have to search EVERY item before finding the desired value. 
But let's suppose we wanted to find '42' in the BST. Well, we'd merely go to 40 and ask: if 42 greater than 40 or less than? Obviously 42 is greater
than 40, so we go to the right in search for higher values since in a BST all vaues to the right of the root are greater. Then, we encounter 45
and make the same judgement. We move to the left of 45 since 42 is < 45 and we have found our desired value! That only took 3 comparsions 
(remember, we are including 42 in the comparsion count - you could say it only took two comparsions which would be 40 and 45, but we also had to judge
if the number 42 was equal to the number we were looking for so we say 3 comparsions). 


This is compared to randomly going through numbers which, in the worst case we'd have to go through every element during our comparsions 
(in case our desired element was at the last position or wasn't there at all) -- that's why they say: for N elements, and for linear searching the
time complexity is O(N) - which basically means at the worst case we'd have to search through all N elements, so O(N). 

Efficency in regard to a BST:
We have already established that it takes very few comparsions when searching for an element in a BST as compared to a linear data structure. 
This is primarily because on the very first comparsion - depending on whether the root is greater than or less than the element we want to find - 
we disregard half of the BST entirely (this is because items to the left of the root are less than the root, and items to the right are greater). 
You can imagine that we do this for each node as we search for our element. For instance, the next element we check will be subject to our comparsion
(where we will check if it is greater than or less than the node/item and we will move left/right accordingly) - hence, we disregard a subtree and 
avoid several comparsions by doing this. 

There is a mathematical function that can encapsulate this reduction in comparsions: The Logorithim. 

So we know what the time complexity is in the worst case for linear data stuctures (O(N) since in the worst case N elements are subject to N comparsions) 
but what about the worst case for a BST?
Well, it is Log(n) 

Example: There are only four comparsionsin finding a desired element among 16 elements. So for N elements there would be Log(N) comparsions
in the worst case. But actually - since we ALSO compare the root, it will take Log(N) + 1 comparsions, so 17. 

So, if there are 128 items, it would merely take Log(N) - Log(128) = 7 comparsions to find the desired element. However, since we must also 
consider the root, it would be Log(128) + 1, so 8. 

Different Tree Traversals:

Note: To make a BST and judge what the Post/Pre/Inorder traversal will be go to this website! 
https://yongdanielliang.github.io/animation/web/BST.html

- Inorder Traversal 
  Inorder traversal has a visitation order of left, node itself, then right: LNR. 
  Following this pattern yeilds all elements of a BST in 'order' (ascending) 
      40 
    13  45   ===> Inorder: 8, 13, 26, 40, 42, 45, 98
   8 26 42 98
           
- Postorder Traversal 
  Postorder traversal has a visitation order of left, right, 'node itself': LRN. 
  A good way to remember this is: 'post' often means 'after' - so the 'node itself' is considered 'after' L and R. 

    40 
   13 45   ===> Postorder: 8, 26, 13, 42, 98, 45, 40. 
 8 26 42 98
           

- Preorder Traversal 
  This one is 'node itself' first, and then L and R. 
    40 
   13 45   ===> Preorder: 40, 13, 18, 26, 45, 42, 98 
 8 26 42 98
           

Building a BST (or Tree)
- We will have a node that has two links and data. 
           [ LINK1 | Data | LINK2 ] 
             /                \ 
[ LINK1 | Data | LINK2 ]  [ LINK1 | Data | LINK2 ] 



==>> BinaryNode Class <<==

package TreeProject;

public class BinaryNode<T extends Comparable<T>> extends Object { //Comparable interface has a method called compareTo (-1, 0 , 1)
    //instance variables
    private T data;
    private BinaryNode<T> left;  //reference to a BinaryNode<T> Object
    private BinaryNode<T> right;  //reference to a BinaryNode<T> Object
    
    //constructor
    public BinaryNode(T newData) {
        super();
        data = newData;
        left = null;
        right = null;
    }
    
    //non-static methods
    public void setData(T newData) {
        data = newData;
    }
    public T getData() {
        return data;
    }
    public void setLeft(BinaryNode<T> otherNode) {
        this.left = otherNode;
    }
    public BinaryNode<T> getLeft(){
        return left;
    }
    
    public void setRight(BinaryNode<T> otherNode) {
        this.right = otherNode;
    }
    public BinaryNode<T> getRight(){
        return right;
    }
    
}
======================================================================================================================================================
