public class Employee extends Person {
    //as you can see, 'extends Person' means 'Person' class is parent, and 'Employee' class is child.
    //private variables of Person will not be available to employee (although that's what we want

    //there is an instance variable that is unique to employee
    private int employeeID;

    public Employee() {
        super(); //this will call constructor of parent class and then set default values that are within parent
        employeeID = 0; //I am still providing default value explicitly for what instance variable is within employee
    }

    //for this overloaded const. - passing in name, so sent to super that calls constructor w. name, but employeeID still
    //defaulted since a value wasn't explicitly passed in for that.
    public Employee(String name) {
        super(name);
        employeeID = 0;
    }

    public Employee(String name, int employeeID) {
        //will make a call to the constructor of the super class that accepts 'name' as a parameter.
        //we would receive an error if the parent class didn't have an overloaded constructor with parameter name.
        super(name);
        /*
        since they have passed in 'employeeID', it won't make sense to say employeeID = 0, that take the users
        input for employeeID and force it to be 0. Passing it in the constructor of employee is trying to set
        a new value for the employeeID field that is something other than the default value. As such, we should
        pass the new employeeID to setName.
         */
        setEmployeeID(employeeID);
    }

    //this overloaded constructor just receives the employeeID, so let's call super() to get all the variables
    //defined in person attached to Employee (obviously we won't do super(employeeID) since the employeeID field isn't
    //available in 'Person' and as such there isn't an overloaded constructor which has 'employeeID' as a parameter
    //in person.
    public Employee(int employeeID) {
        super();
        setEmployeeID(employeeID);
    }

    /*
        You might be wondering since Employee has the instance variable name through 'super' - and all other instance
        variables defined in the 'Person' class, where are
        setName and getName defined in this class? Well,
        they are defined in 'Person' and are available to Employee (since you will inherit public methods/vars)
        however, we don't need to define that within the Employee class
    */

    //we will still define methods that relate to instance variables unique to the 'Employee' class.
    public void setEmployeeID(int employeeID) {
        if(employeeID > 0) { //check within the setter if employeeID > 0..
            this.employeeID = employeeID;
        }
    }

    //getter for employeeID
    public int getEmployeeID() {
        return employeeID;
    }

    /*
    this implementation of toString for the Employee will provide a String representation of the Object
    So, We would have to retrieve the name - however, the name is not provided within the current class because it is a private
    field defined within the parent class (in this case, Person).
    we may either do "Name: " + getName or.. this.getName() or.. super.getName()
    super.getName works because the private field 'name' was defined in Person and that is where 'Employee' received the field from
    it basically says to call the getName method from the super class.
    */

    public String toString() {
        return "Name: " + super.getName() + "Employee ID: " + this.employeeID;
    }


    //if the otherObject isn't null and the otherObject is an instance of type Employee, then cast the incoming employee to
    //Employee type and see if their attributes are the same.
    public boolean isEqual(Object otherObject) {
        boolean areTheyEqual = false;
        if(otherObject != null && otherObject instanceof Employee) {
            Employee incomingEmployee = (Employee)(otherObject);
            if(this.employeeID == incomingEmployee.employeeID && this.getName().equals(incomingEmployee.getName())) {
                areTheyEqual = true;
            }
        }
        return areTheyEqual;
    }

}
